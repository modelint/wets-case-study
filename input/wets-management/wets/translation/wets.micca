# This file contains the micca source for the WETS domain as
# analyzed by Michael Lee.
# This translation is derived from the Model Integration
# Wets Case Study repository on github.
#
# class model xcm metadata
#    Title : Water Elevation Transit System Class Model
#    Author : Michael Lee
#    Document ID : none
#    Version : 0.16
#    Creation date : 27-02-2025
#    Modification date: 05-08-2025
#    Organization : Model Integration, LLC / www.modelint.com
#    Copyright notice > MIT
#    Organization logo > mint
#

domain wets {
    typealias WetsName_t {char [16]}
    typealias VesselLicense_t {char [16]}
    typealias GateName_t {char [16]}
    typealias ValveName_t {char [16]}
    typealias CulvertName_t {char [16]}
    typealias TransferDirection_t {enum {
        dir_up,
        dir_down,
    }}
    typealias MotionStatus_t {enum {
        ms_moving,
        ms_secured,
    }}
    typealias TransitLaneName_t {char [16]}
    typealias GateStatus_t {enum {
        gt_open,
        gt_opening,
        gt_closed,
        gt_closing,
    }}
    typealias ValveStatus_t {enum {
        vl_open,
        vl_opening,
        vl_closed,
        vl_closing,
    }}

    class Wets {
        attribute Name WetsName_t
        attribute Last_waiting_position uint8_t -default 0

        #state model xsm metadata
        #   Title : Wets State Machine Diagram
        #   Author : Michael M. Lee
        #   Document ID : mint.wets.td.4
        #   Modification date : August 9, 2025
        #   Version : 0.10.1 -- correction to Service Transfer Request activity
        #   Organization : Model Integration, LLC
        #   Copyright notice > MIT
        #   Organization logo > mint

        statemodel {
            initialstate Idle
            defaulttrans CH

            state Idle {} {}
            transition Idle - Transfer_request -> Service_Transfer_Request
            transition Idle - Removal_request -> Service_Removal_Request
            transition Idle - Transfer_completed -> Service_Transfer_Completed

##############
# // Make sure this isn't a redundant request by first attempting
# // to find a vessel with the same license number
# identical vessel .= Vessel(License == ^new license)
# identical vessel?
#     // If there is vessel with the same license number, reject this request
#     Request denied(vessel license: ^new license) -> VESSEL :
#     // If not, then increment the Last waiting position
#     {
#         ++Last waiting position 
#         // Now see if there are any available transit lanes
#         available transit lanes ..= /R1/Transit Lane( ! /R4/Assigned Vessel )
#         available transit lanes?
#            // There are available transit lanes, see if there is one the same available
#            // transfer direction as the requested direction
#            {
#                 chosen transit lane .= available transit lanes(1, available transfer direction : ^direction)
#                 // If there isn't one in the same direction, just use one of the available ones
#                 !chosen transit lane? chosen transit lane .= available transit lanes(1)
#                 // Get the first gate for traversing the chosen transit lane in the requested direction.
#                 / If requested direction is up, then first gate will be downstream, otherwise it will be upstream.
#                 ^direction == _up?
#                     first gate .= chosen transit lane/R5/Transit Lane Gate/OR7/downstream/~| :
#                     first gate .= chosen transit lane/R5/Transit Lane Gate/OR7/upstream/~|
#                 // Create an Assigned Vessel and establish relationships
#                 new vessel .= *Vessel(License: ^new license, Transfer direction: ^direction)
#                   &R2 *Assigned Vessel( Status: _moving) &R4 chosen transit lane
#                 // Create the associative class Active Gate Move 
#                 *Active Gate Move &R10 new vessel/R2/Assigned Vessel, first gate
#                 // Send an event to the transit lane to let it know it has a vessel to move
#                 Vessel assigned -> chosen transit lane
#             } : {
#               // No Transit Lanes are available, so create a Waiting Vessel and establish relationships
#               *Vessel(License: ^new license, Transfer direction: ^direction)
#                   &R2 *Waiting Vessel(Waiting position: me.Last waiting position) &R3 me
#             }
#         // Send an event to the requesting vessel to let it know that its request has been granted
#         Request granted(vessel license: ^new license) -> VESSEL
#     }
# //  Go back to the Idle state and wait for more work
# Continue -> me
##############

            state Service_Transfer_Request {
                new_license VesselLicense_t
                direction TransferDirection_t
            } {
            <%  Vessel findWhere identical_vessel {strcmp(identical_vessel->License, new_license) == 0} %>
                if (identical_vessel != NULL) {
            <%      VESSEL Request_denied vessel_license new_license %>;
                } else {
            <%      instance self assign Last_waiting_position                                          %>
                    Last_waiting_position += 1;
            <%      instance self update Last_waiting_position Last_waiting_position                    %>

                    // This variable reference must be available within the else scope.
            <%      Transit_Lane refvar chosen_transit_lane                                             %>
                    // Once we are here, we will create an instance of Vessel and we need
                    // the variable scope to be available for the "if" test below
            <%      Vessel create v License new_license Transfer_direction direction                    %>

                    // Micca does not have a "traverse complement" (or semi-minus or anti-join) operation
                    // so we have to construct one ourselves. The strategy is to select all the
                    // related Transit Lane instances and iterate over them to determine which
                    // one is _not_ related across R4. Those instances are then added to the
                    // set of available transit lanes (which starts off empty).
            <%      Transit_Lane instset available_transit_lanes                                        %>
            <%      instance self selectRelated transit_lanes ~R1                                       %>
            <%      instset transit_lanes foreachInstance possible_lane                                 %>
            <%      instance possible_lane findOneRelated assigned_vessel ~R4                           %>
                    if (assigned_vessel == NULL) {
            <%          instset available_transit_lanes add possible_lane                               %>
                    }
            <%      end                                                                                 %>

                    if (<% instset available_transit_lanes notempty %>) {
            <%          instset available_transit_lanes foreachInstance chosen_transit_lane             %>
                            if (<% instance chosen_transit_lane attr Available_transfer_direction %> == direction) {
                                break;
                            }
            <%          end                                                                             %>
                        if (chosen_transit_lane == NULL) {
            <%              instset available_transit_lanes selectOneInstance chosen_transit_lane       %>
                        }

            <%          Transit_Lane_Gate refvar first_gate                                             %>
                        if (direction == dir_up) {
                            first_gate =
                                <% Transit_Lane_Gate operation Upstream_head transit_lane chosen_transit_lane %>;
                        } else {
                            first_gate =
                                <% Transit_Lane_Gate operation Downstream_head transit_lane chosen_transit_lane %>;
                        }
            <%          Assigned_Vessel create av Status ms_moving R2 v R4 chosen_transit_lane              %>
            <%          Active_Gate_Move create agm R10 {Assigned_Vessel av Transit_Lane_Gate first_gate}   %>
            <%          instance chosen_transit_lane signal Vessel_assigned                                 %>
                    } else {
            <%          Waiting_Vessel create wv Waiting_position Last_waiting_position R2 v R3 self        %>
                    }
            <%      VESSEL Request_granted vessel_license new_license %>;

                }
            <%  instance self signal Continue                                                           %>
            }
            transition Service_Transfer_Request - Transfer_request -> IG
            transition Service_Transfer_Request - Removal_request -> IG
            transition Service_Transfer_Request - Transfer_completed -> IG
            transition Service_Transfer_Request - Continue -> Idle

##############
# // See if this vessel is waiting.
# identical vessel .= Waiting Vessel(License == ^old license)
# !identical vessel?
#     // There is not a waiting vessel with this license number so
#     // send the requestor a request denied.
#     Request denied(vessel license: ^old license) -> VESSEL :
#     {
#     // This vessel is waiting, so send it a Request granted event
#     // and delete it and its super type.
#         Request granted(license: ^old license) -> VESSEL
#         !*Vessel(License: ^old license), Waiting Vessel(License: ^old license)
#     }
# //  Go back to the Idle state and wait for more work.
# Continue -> me
##############

            state Service_Removal_Request {
                old_license VesselLicense_t
            } {
                // Since we have elided the License attribute from Waiting Vessel, we
                // go at the Vessel instances first and then follow them down to the
                // Waiting Vessels. Besides since we may do a deletion across R2, we need to find
                // both instances.
            <%  Vessel findWhere identical_vessel {strcmp(identical_vessel->License, old_license) == 0} %>
                if (identical_vessel == NULL) {
            <%      VESSEL Request_denied vessel_license old_license %>;
            <%      instance identical_vessel findOneRelated waiting_vessel {~R2 Waiting_Vessel}        %>
                    if (waiting_vessel == NULL) {
            <%          VESSEL Request_denied vessel_license old_license %>;
                    } else {
            <%          VESSEL Request_granted vessel_license old_license %>;
            <%          instance waiting_vessel delete                                                  %>
            <%          instance identical_vessel delete                                                %>
                    }
                }
            <%  instance self signal Continue                                                           %>
            }
            transition Service_Removal_Request - Transfer_request -> IG
            transition Service_Removal_Request - Removal_request -> IG
            transition Service_Removal_Request - Transfer_completed -> IG
            transition Service_Removal_Request - Continue -> Idle

############## 0.10
# // Send the  Vessel a Transfer completed event
# Transfer completed (vessel license : ^completed license) -> VESSEL
# // Next delete the associated class Active Gate Move followed by deleting
# // the Supertype Vessel and associated subtype Assigned Vessel.
# !*/R4/R10Active Gate Move
# !*Vessel(License: ^completed license), Assigned Vessel(License: ^completed license)
# // Now get the earliest waiting vessel
# earliest waiting vessel .= me/R3/OR9/earlier/~|
# earliest waiting vessel?
#     // There is an earliest waiting vessel
#     {
#         // First, get the earliest waiting vessel's requested direction
#         requested direction = earliest waiting vessel/R2/Vessel.Transfer direction
#         // Get the first gate for traversing the chosen transit lane in the requested direction.
#         // If requested direction is up, then first gate will be downstream, otherwise it will be upstream.
#         requested direction == .up?
#             first gate .= ^free transit lane/R5/Transit Lane Gate/OR7/downstream/~| :
#             first gate .= ^free transit lane/R5/Transit Lane Gate/OR7/upstream/~|
#         // Migrate the Waiting Vessel to an Assigned Vessel.
#         earliest waiting vessel >> Assigned Vessel(Status: _moving) &R4 ^free transit lane
#         // Create the associative object Active Gate Move
#         *Active Gate Move &R10 ^free transit lane/R4/Assigned Vessel, first gate
#         //  Send an event to the transit lane to let it know it has a vessel to move.
#         Vessel assigned -> ^free transit lane
#     } :
#     // There is no earliest waiting vessel so reset the Last waiting position
#     Last waiting position = 0
# //  Go back to the Idle state and wait for more work
# Continue -> me
##############

            state Service_Transfer_Completed {
                free_transit_lane {struct Transit_Lane *}
                completed_license VesselLicense_t
            } {
            <%  VESSEL Transfer_completed vessel_license completed_license %>;
            <%  Vessel findWhere identical_vessel {strcmp(identical_vessel->License, completed_license) == 0}   %>
                assert(identical_vessel != NULL);
            <%  instance identical_vessel findOneRelated assigned_vessel {~R2 Assigned_Vessel}                  %>
            <%  instance assigned_vessel findOneRelated active_gate_move {R10 Active_Gate_Move}                 %>
            <%  instance active_gate_move delete                                                                %>
            <%  instance assigned_vessel delete                                                                 %>
            <%  instance identical_vessel delete                                                                %>

            <%  Waiting_Vessel refvar earliest_waiting_vessel                                                   %>
                earliest_waiting_vessel = <% Waiting_Vessel operation earliest wets self %>;
                if (earliest_waiting_vessel != NULL) {
            <%      instance earliest_waiting_vessel findOneRelated vessel R2                                   %>
            <%      instance vessel assign {Transfer_direction requested_direction}                             %>

            <%      Transit_Lane_Gate refvar first_gate                                                         %>
                    if (requested_direction == dir_up) {
                        first_gate =
                            <% Transit_Lane_Gate operation Downstream_head transit_lane free_transit_lane %>;
                    } else {
                        first_gate =
                            <% Transit_Lane_Gate operation Upstream_head transit_lane free_transit_lane %>;
                    }
            <%      R2 reclassify earliest_waiting_vessel Assigned_Vessel av \
                        Status ms_moving R4 free_transit_lane %>
            <%      Active_Gate_Move create agm R10 {Transit_Lane_Gate first_gate Assigned_Vessel av}           %>
            <%      instance free_transit_lane signal Vessel_assigned                                           %>
                } else {
            <%      instance self update Last_waiting_position 0                                                %>
                }

            <%  instance self signal Continue                                                                   %>
            }
            transition Service_Transfer_Completed - Transfer_request -> IG
            transition Service_Transfer_Completed - Removal_request -> IG
            transition Service_Transfer_Completed - Transfer_completed -> IG
            transition Service_Transfer_Completed - Continue -> Idle
        }
    }

    class Transit_Lane {
        attribute Name TransitLaneName_t
        attribute Available_transfer_direction TransferDirection_t

        #state model xsm metadata
        #    Title : Transit Lane State Machine Diagram
        #    Author : Michael M. Lee
        #    Document ID : mint.wets.td.4
        #    Creation date : May 23, 2025
        #    Version : 0.8.1 -- Minor change to Assess Adjustment Complete activity
        #    Organization : Model Integration, LLC
        #    Copyright notice > MIT
        #    Organization logo > mint

        statemodel {
            initialstate Idle
            defaulttrans CH

            # empty
            state Idle {} {
            }
            transition Idle - Vessel_assigned -> Assess_Water_Level

##############
# // See if the Assigned Vessel's transfer direction is the same as this
# // Transit Lane's Available transfer direction
# (/R4/R2/Vessel.Transfer direction == Available transfer direction)?
# // Same transfer direction, so no water adjustments to do. Start transfer.
#     Start transfer -> me :
# // Different transfer directions, so we need to:
# //1 - Change the Available transfer direction for this Transit Lane
# Available transfer direction == _up?
#     Available transfer direction = _down :
#     Available transfer direction = _up
# //2 - Get the set of Adjustment Steps to do this
# adjustment step set .. = /R11/Adjustment Step (transit lane : Name ;
#   Adjustment direction : Available transfer direction)
# //3 - Get the first step in this set
# starting step .= adjustment step set/OR13/before/~|
# //4 - Create the associative class Active Step
# *Active Step &R12 me, starting step
# //5 - Then go do the Active Step adjustment
# Make adjustments -> me
##############

            state Assess_Water_Level {} {
            <%  instance self findOneRelated assigned_vessel ~R4                        %>
                // Since we get to this state only after a vessel has been assigned
                // we are assured that R4 from Transit Lane to Assigned Vessel
                // results in finding an instance of Assigned Vessel.
                assert(assigned_vessel != NULL);
            <%  instance assigned_vessel findOneRelated vessel R2                       %>
            <%  instance vessel assign Transfer_direction                               %>
            <%  my assign Available_transfer_direction                                  %>
                if (Transfer_direction == Available_transfer_direction) {
            <%      my signal Start_transfer                                            %>
                } else {
                    Available_transfer_direction = (Available_transfer_direction == dir_up) ?
                        dir_down : dir_up;
            <%      my update Available_transfer_direction Available_transfer_direction %>
                    // find first step in set => starting_step
            <%      Adjustment_Step refvar starting_step                                %>
                    starting_step = <% my operation Starting_step %>;
            <%      Active_Step create astep R12 {Transit_Lane self Adjustment_Step starting_step}  %>
            <%      my signal Make_adjustments                                          %>
                }
            }
            transition Assess_Water_Level - Make_adjustments -> Request_Gate_Adjustment
            transition Assess_Water_Level - Start_transfer -> Request_Gate_Move

##############
# // Get the gate needing to do a move
# move gate .= /R4/R10/Transit Lane Gate
# Move vessel -> move gate
##############
            state Request_Gate_Move {} {
            <%  my findOneRelated move_gate ~R4 R10                                 %>
            <%  instance move_gate signal Move_vessel                               %>
            }
            transition Request_Gate_Move - Move_complete -> Assess_Transfer_Complete

##############
# // Tell the gate for the Active Step to adjust its level.
# Adjust level -> /R12/Adjustment Step/R14/Transit Lane Gate
##############
            state Request_Gate_Adjustment {} {
            <%  my findOneRelated transit_lane_gate ~R12 R14                        %>
            <%  instance transit_lane_gate signal Adjust_level                      %>
            }
            transition Request_Gate_Adjustment - Adjust_complete -> Assess_Adjustment_Complete

##############
# // 1 - Get the next Transit Lane Gate to be adjusted
# //     and delete the old one.
# next step .= /R12/Adjustment Step/OR13/after
# !*/R12/Active Step
# // 2 - Do we have a next step?
# next step?
# //3A - We have a next step create a new Active Step and go do it
# {
#     *Active Step &R12 me, next step
#     Continue adjustments -> me
# } :
# //3B - We don't have a next step, start the transfer
# {   Start transfer -> me}
##############

            state Assess_Adjustment_Complete {} {
            <%  my findOneRelated current_step ~R12 %>
            <%  instance current_step assign {Step_number current_step_number}  %>
            <%  my findRelatedWhere next_step\
                    {next_step->Adjustment_direction == current_step->Adjustment_direction &&\
                    next_step->Step_number == current_step_number + 1} ~R11 %>
            <%  my findOneRelated active_step {~R12 Active_Step}                %>
            <%  instance active_step delete                                     %>
                if (next_step != NULL) {
            <%      Active_Step create astep R12 {Transit_Lane self Adjustment_Step next_step}  %>
            <%      my signal Continue_adjustment                               %>
                } else {
            <%      my signal Start_transfer                                    %>
                }
            }
            transition Assess_Adjustment_Complete - Continue_adjustment -> Request_Gate_Adjustment
            transition Assess_Adjustment_Complete - Start_transfer -> Request_Gate_Move

##############
# // Get the last Transit Lane Gate moved past
# last transit lane gate .= /R4/R10/Transit Lane Gate
# // Get the next Transit Lane Gate in the vessel's transfer direction
# /R4/R2/Vessel.Transfer direction == _up?
# // Going up, next gate will bw upstream 
#     next transit lane gate .= last transit lane gate/OR7/upstream :
# //Going down, next gate will be downstream
#     next transit lane gate .= last transit lane gate/OR7/downstream
# // Is there a next transit lane gate or are we finished?
# next transit lane gate?  
# // Yes we have one, relate the vessel to this new gate via R10 and the
# // associative class Active Gate Move and continue transfer
# {
#     *Active Gate Move &R10 /R4/Assigned Vessel, next transit lane gate
#     Continue transfer -> me 
# } : 
# {
# // No, we don't have one, the last gate move must have completed the vessel's transfer.
# // Report transfer completed to Wets and return to idle state.
#     Transfer completed (free transit lane : me, completed license : /R4/R2/Vessel.License) -> /R1/Wets
#     Finished transfer -> me
# }
##############
            state Assess_Transfer_Complete {} {
            <%  my findOneRelated assigned_vessel ~R4                                   %>
            <%  instance assigned_vessel findOneRelated last_transit_lane_gate R10      %>
            <%  instance assigned_vessel findOneRelated vessel R2                       %>
            <%  instance vessel assign Transfer_direction                               %>
            <%  instance last_transit_lane_gate assign {Position last_position} %>
            <%  Transit_Lane_Gate refvar next_transit_lane_gate                         %>
                if (Transfer_direction == dir_up) {
                    uint8_t next_position = last_position + 1;
            <%      my findRelatedWhere next_transit_lane_gate\
                        {next_transit_lane_gate->Position == next_position}\
                        {~R5 Transit_Lane_Gate}                                         %>
                } else if (last_position != 0) {
                    uint8_t next_position = last_position - 1;
            <%      my findRelatedWhere next_transit_lane_gate\
                        {next_transit_lane_gate->Position == next_position}\
                        {~R5 Transit_Lane_Gate}                                         %>
                }

                if (next_transit_lane_gate != NULL) {
            <%      instance assigned_vessel findOneRelated active_gate_move\
                        {R10 Active_Gate_Move}                                          %>
            <%      R10 reference active_gate_move next_transit_lane_gate               %>
            <%      my signal Continue_transfer                                         %>
                } else {
            <%      instance vessel assign License                                      %>
            <%      my findOneRelated wets R1                                           %>
            <%      instance wets signal Transfer_completed free_transit_lane self completed_license License    %>
            <%      my signal Finished_transfer                                         %>
                }
            }
            transition Assess_Transfer_Complete - Continue_transfer -> Request_Gate_Move
            transition Assess_Transfer_Complete - Finished_transfer -> Idle
        }

        # This instance op calculates the first step in the OR13 ordinal association
        instop {struct Adjustment_Step *} Starting_step {} {
        <%  my selectRelatedWhere adjustment_steps adjustment_step {\
                    adjustment_step->Adjustment_direction == self->Available_transfer_direction} ~R11 %>
            unsigned min_step_number = UINT8_MAX;
        <%  Adjustment_Step refvar starting_step                                                %>
        <%  instset adjustment_steps foreachInstance adjustment_step                            %>
        <%      instance adjustment_step assign Step_number                                     %>
                if (Step_number < min_step_number) {
                    min_step_number = Step_number;
                    starting_step = adjustment_step;
                }
        <%  end                                                                                 %>
            return starting_step;
        }
    }

    class Gate {
        attribute Name GateName_t
        attribute Status GateStatus_t
    }

    class Valve {
        attribute Name ValveName_t
        attribute Status ValveStatus_t
    }

    # Transit Lane Gate participates in an ordinal reflexive association.
    # The association is a "sequential" association, i.e. a list.
    # We implement this by using a number and a couple of class operations
    # to find the beginning and end by simply finding the smallest and
    # largest value of the Transit position attribute.
    class Transit_Lane_Gate {
        attribute Position uint8_t -default 0

        #state model xsm metadata
        #    Title : Transit Lane Gate State Machine Diagram
        #    Author : Michael M. Lee
        #    Document ID : mint.wets.td.5
        #    Creation date : June 3, 2025
        #    Version : 0.6
        #    Organization : Model Integration, LLC
        #    Copyright notice > MIT
        #    Organization logo > mint

        statemodel {
            initialstate Secured_At_Rest
            defaulttrans CH

##############
# empty
##############
            state Secured_At_Rest {} {}
            transition Secured_At_Rest - Move_vessel -> Open_Valve
            transition Secured_At_Rest - Adjust_level -> Open_Valve_Adjust

##############
# // Direct my valve to open
# Transit Lane Gate.Open valve()
##############
            state Open_Valve {} {
            <%  my operation Open_valve %>;
            }
            transition Open_Valve - Valve_opened -> Wait_For_Zero_Flow

##############
# // Direct my valve to open
# Transit Lane Gate.Open valve()
##############
            state Open_Valve_Adjust {} {
            <%  my operation Open_valve %>;
            }
            transition Open_Valve_Adjust - Valve_opened -> Wait_For_Zero_Flow_Adjust

##############
# // Direct my culvert to notify me when the flow through it
# // from the open valve is zero
# Transit Lane Gate.Wait for zero flow()
##############
            state Wait_For_Zero_Flow {} {
            <%  my operation Wait_for_zero_flow %>;
            }
            transition Wait_For_Zero_Flow - Flow_zero -> Open_Gate

##############
# // Direct my culvert to notify me when the flow through it
# // from the open valve is zero
# Transit Lane Gate.Wait for zero flow()
##############
            state Wait_For_Zero_Flow_Adjust {} {
            <%  my operation Wait_for_zero_flow %>;
            }
            transition Wait_For_Zero_Flow_Adjust - Flow_zero -> Close_Valve_Adjust

##############
# // Direct this gate, with an open valve and no water flow through its culvert, to open
# Open (gate name : me.Gate) -> GATE
##############
            state Open_Gate {} {
            <%  instance self findOneRelated my_gate ~R5            %>
            <%  instance my_gate assign {Name my_gate_name}         %>
                MRT_InstId me = <% my instid %>;
            <%  GATE Open gate_name my_gate_name return_id me %>;
            }
            transition Open_Gate - Gate_opened -> Move_Vessel

##############
# // Change my vessel status to "moving" and direct it to move past this gate
# /R10/Awaiting Vessel.status = _moving
# My vessel license = /R10/Assigned vessel.License
# Move past gate (vessel license : My vessel license, transit lane gate name : me.Gate) -> VESSEL
##############
            state Move_Vessel {} {
            <%  instance self findOneRelated awaiting_vessel ~R10       %>
            <%  instance awaiting_vessel update Status ms_moving        %>
            <%  instance awaiting_vessel findOneRelated my_vessel R2    %>
            <%  instance my_vessel assign {License My_vessel_license}   %>
            <%  instance self findOneRelated my_gate ~R5                %>
            <%  instance my_gate assign {Name My_gate_name}             %>
                MRT_InstId me = <% my instid %>;
            <%  VESSEL Move_past_gate vessel_license My_vessel_license return_id me %>;
            }
            transition Move_Vessel - Moved_past_gate -> Close_Gate

##############
# // Change my vessel status to "secured" and direct this gate to close.
# /R10/Awaiting Vessel.status = _secured
# Close (gate name : me.Gate) -> GATE
##############
            state Close_Gate {} {
            <%  instance self findOneRelated awaiting_vessel ~R10   %>
            <%  instance awaiting_vessel update Status ms_secured   %>
            <%  instance self findOneRelated my_gate ~R5            %>
            <%  instance my_gate assign {Name My_gate_name}         %>
                MRT_InstId me = <% my instid %>;
            <%  GATE Close gate_name My_gate_name return_id me %>;
            }
            transition Close_Gate - Gate_closed -> Close_Valve

##############
# // Direct my valve to close
# Transit Lane Gate. Close valve()
##############
            state Close_Valve {} {
            <%  my operation Close_valve %>;
            }
            transition Close_Valve - Valve_closed -> Complete_Move

##############
# // Direct my valve to close
# Transit Lane Gate. Close valve()
##############
            state Close_Valve_Adjust {} {
            <%  my operation Close_valve %>;
            }
            transition Close_Valve_Adjust - Valve_closed -> Complete_Adjust

##############
# // Notify my Transit Lane that the requested move has been completed.
# My transit lane := /R5/Transit Lane
# Move completed () -> My transit lane
##############
            state Complete_Move {} {
            <%  my findOneRelated My_transit_lane R5                %>
            <%  instance My_transit_lane signal Move_complete       %>
            <%  my signal Move_completed                            %>
            }
            transition Complete_Move - Move_completed -> Secured_At_Rest

##############
# // Notify my Transit Lane that the requested move has been completed.
# My transit lane := /R5/Transit Lane
# Move completed () -> My transit lane
##############
            state Complete_Adjust {} {
            <%  my findOneRelated My_transit_lane R5                %>
            <%  instance My_transit_lane signal Adjust_complete     %>
            <%  my signal Adjust_completed                          %>
            }
            transition Complete_Adjust - Adjust_completed -> Secured_At_Rest
        }

        # These two class operations were introduced into the translation
        # to handle the OR7 association traversal. Note that OR7 does not
        # appear as a micca association. This association is used as a
        # sequential relation and the only operations present in the
        # state activities happen at the head or tail. The Transit Position
        # attribute is used to keep the order implied by the association.
        # The values of Transit Position are ordered by the initial instance
        # population and do not change at run time since we don't create
        # Transit Lane instance or Gates on the fly.
        classop {struct Transit_Lane_Gate *} Upstream_head {
            transit_lane {struct Transit_Lane *}
        } {
        <%  Transit_Lane_Gate refvar upstream_gate                                          %>
        <%  instance transit_lane selectRelated lane_gates {~R5 Transit_Lane_Gate}          %>
            unsigned max_pos = UINT32_MAX;
        <%  instset lane_gates foreachInstance lane_gate                                    %>
        <%      instance lane_gate assign Position                                  %>
                if (Position < max_pos) {
                    max_pos = Position;
                    upstream_gate = lane_gate;
                }
        <%  end                                                                             %>
            return upstream_gate;
        }

        classop {struct Transit_Lane_Gate *} Downstream_head {
            transit_lane {struct Transit_Lane *}
        } {
        <%  Transit_Lane_Gate refvar downstream_gate                                        %>
        <%  instance transit_lane selectRelated lane_gates {~R5 Transit_Lane_Gate}          %>
            unsigned min_pos = 0;
        <%  instset lane_gates foreachInstance lane_gate                                    %>
        <%      instance lane_gate assign Position                                  %>
                if (Position > min_pos) {
                    min_pos = Position;
                    downstream_gate = lane_gate;
                }
        <%  end                                                                             %>
            return downstream_gate;
        }

        instop void Open_valve {} {
        <%  my findOneRelated my_valve ~R5 R6 R8                %>
        <%  instance my_valve assign {Name My_valve_name}       %>
            MRT_InstId me = <% my instid %>;
        <%  VALVE Open valve_name My_valve_name return_id me %>;
        }

        instop void Close_valve {} {
        <%  my findOneRelated my_valve ~R5 R6 R8                %>
        <%  instance my_valve assign {Name My_valve_name}       %>
            MRT_InstId me = <% my instid %>;
        <%  VALVE Close valve_name My_valve_name return_id me %>;
        }

        instop void Wait_for_zero_flow {} {
        <%  my findOneRelated my_culvert ~R5 R6                 %>
        <%  instance my_culvert assign {Name My_culvert_name}   %>
            MRT_InstId me = <% my instid %>;
        <%  CULVERT Indicate_no_flow culvert_name My_culvert_name return_id me %>;
        }
    }

    class Vessel {
        attribute License VesselLicense_t
        attribute Transfer_direction TransferDirection_t
    }

    class Assigned_Vessel {
        attribute Status MotionStatus_t
    }

    class Waiting_Vessel {
        attribute Waiting_position uint8_t

        # Waiting Vessel participates in an ordinal reflexive association, OR9.
        # The association is a "sequential" association, i.e. a list.
        # We implement this by using the Waiting Position attribute.
        # The state activities are only interested in finding the head of the
        # implied list. The values of Waiting Position are managed by the
        # Wets class to insure that they are monotonically increasing.
        # Note this function can return NULL which indicates that there
        # are no Waiting Vessel instances for this Wets.
        classop {struct Waiting_Vessel *} earliest {
            wets {struct Wets *}
        } {
        <%  Waiting_Vessel refvar earliest                          %>

            // For some reason micca is unhappy about using the "wets"
            // argument directly in the selectRelated command.
        <%  Wets refvar the_wets                                    %>
            the_wets = wets;
        <%  instance the_wets selectRelated waiting_vessels ~R3     %>
            if (<% instset waiting_vessels empty %>) {
                return NULL;
            }
            unsigned max_pos = UINT32_MAX;
        <%  instset waiting_vessels foreachInstance waiting_vessel   %>
        <%      instance waiting_vessel assign Waiting_position      %>
                if (Waiting_position < max_pos) {
                    max_pos = Waiting_position;
                    earliest = waiting_vessel;
                }
        <%  end                                                     %>
            return earliest;
        }
    }

    class Culvert {
        attribute Name CulvertName_t
    }

    class Adjustment_Step {
        attribute Adjustment_direction TransferDirection_t
        attribute Step_number uint8_t
    }

    class Active_Step {
    }

    class Active_Gate_Move {
    }

    association R1 -static Transit_Lane +--1 Wets

    generalization R2 -union Vessel\
        Waiting_Vessel Assigned_Vessel

    association R3 Waiting_Vessel *--1 Wets

    association R4 Assigned_Vessel ?--1 Transit_Lane

    association R5 -associator Transit_Lane_Gate -static\
        Gate +--1 Transit_Lane

    association R6 -static Gate 1--1 Culvert

    association R8 -static Culvert 1--1 Valve

    association R10 -associator Active_Gate_Move\
        Assigned_Vessel ?--? Transit_Lane_Gate

    association R11 Adjustment_Step +--1 Transit_Lane

    association R12 -associator Active_Step\
        Adjustment_Step ?--? Transit_Lane 

    association R14 Adjustment_Step +--1 Transit_Lane_Gate

    eentity VESSEL {
        operation void Request_granted {
            vessel_license {const char *}
        } {
            MRT_DEBUG("ee VESSEL op Request_granted name %s\n", vessel_license);
        }

        operation void Request_denied {
            vessel_license {const char *}
        } {
            MRT_DEBUG("ee VESSEL op Request_denied name %s\n", vessel_license);
        }

        operation void Transfer_completed {
            vessel_license {const char *}
        } {
            MRT_DEBUG("ee VESSEL op Transfer_completed name %s\n", vessel_license);
        }

        operation void Move_past_gate {
            vessel_license {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("ee VESSEL op Move_past_gate name %s return %u\n", vessel_license, return_id);
        }
    }

    # VALVE interactions
    eentity VALVE {
        operation void Open {
            valve_name {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("ee VALVE op Open name %s return %u\n", valve_name, return_id);
        }

        operation void Close {
            valve_name {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("ee VALVE op Close name %s return %u\n", valve_name, return_id);
        }
    }

    eentity CULVERT {
        operation void Indicate_no_flow {
            culvert_name {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("Indicate no flow: %s\n", culvert_name);
            MRT_DEBUG("ee CULVERT op Indicate_no_flow name %s return %u\n", culvert_name, return_id);
        }
    }

    # GATE interactions
    eentity GATE {
        operation void Open {
            gate_name {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("ee GATE op Open name %s return %u\n", gate_name, return_id);
        }

        operation void Close {
            gate_name {const char *}
            return_id MRT_InstId
        } {
            MRT_DEBUG("ee GATE op Close name %s return %u\n", gate_name, return_id);
        }
    }
}
